import{_ as a}from"./4_git_flow-ddf7f0b8.js";import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as d,o as n,c as l,b as e,d as t,e as o,f as s}from"./app-80ad2c53.js";const c={},h=s('<p>这篇文章是 git 系列第三篇，想介绍一下团队分支的管理。在我们的开发工作中，为了对流程进行更好的管理，更好地交付产品，应该充分地利用分支这个功能。这里我想介绍一下自己认为比较完备的、通用的 git 分支管理策略。开始之前，要先说明一下我认为的“通用”是针对什么样的开发流程的，它的特点如下：</p><ul><li>有固定的迭代周期，一般是两周。</li><li>每个迭代结束后进行一次产品发布。迭代周期中不发布产品，除非是 hotfix / 紧急问题。</li><li>产品只有一个主版本。大多数基于 web 的产品都是这样的，不符合这个条件的产品一般是针对不同客户、国家等条件同时维护着多个正式版本。</li></ul><p>下面就列一个表格来说一下具体的分支划分：</p><table><thead><tr><th>分支名</th><th>说明</th></tr></thead><tbody><tr><td><code>dev</code></td><td>开发工作的主分支。迭代开始时，每个开发人员从这个分支创建自己开发任务的 feature 分支；迭代周期的开发工作结束时，用这个分支的代码进行产品发布。（你可能觉得从 dev 分支发布产品有点问题，我在后面做解释）</td></tr><tr><td><code>master</code></td><td>线上产品代码的分支。产品发布后，dev 分支的代码被 merge 到这个分支。当线上出现紧急问题，需要进行 hotfix 时，从这个分支创建 hotfix 分支。</td></tr><tr><td><code>f_xxx</code></td><td>以“f_”开头的开发任务分支，也叫 feature 分支。从 dev 分支创建，开发任务完成后 merge 到 dev 分支。</td></tr><tr><td><code>hotfix_xxx</code></td><td>以“hotfix_”开头的 hotfix 分支。从 master 分支创建；通过发布此分支修复线上紧急问题。问题修复后，要把当前 hotfix 分支的代码 merge 到 master 和 dev 分支。</td></tr></tbody></table><p>根据表格中的描述，实际开发中的 git 流程会是这个样子：</p><figure><img src="'+a+'" alt="git flow" tabindex="0" loading="lazy"><figcaption>git flow</figcaption></figure><p>那么按照这个管理方式，测试是如何进行的呢？首先是随着 feature 分支的开发完成，测试工程师在 dev 分支上进行对应的功能测试；hotfix 的测试要在 hotfix 分支上进行，不能在合并后的 dev 分支上进行；feature 分支和 hotfix 分支都合并到 dev 分支后在 dev 分支进行针对用户体验和产品流程的测试。</p><p>最后，产品 / 紧急修复发布后，别忘了在 master 分支打 tag。</p><h3 id="缺陷" tabindex="-1"><a class="header-anchor" href="#缺陷" aria-hidden="true">#</a> 缺陷</h3><p>这个管理方式有一个问题，那就是没有预发布分支（release），或者说开发分支和预发布分支没有分开，只用了一个 dev 分支。上面表格的括号中要解释的也是这个问题。使用 release 和 dev 分支分开的方式有以下优势：</p><ol><li>把针对功能的测试和针对操作流程的测试隔离开</li><li>dev 分支的代码合并到 release 分支后可以更早地用于后续的开发工作</li></ol>',11),f={href:"https://www.jianshu.com/p/4d7512b78562",target:"_blank",rel:"noopener noreferrer"},_={href:"https://nvie.com/posts/a-successful-git-branching-model/",target:"_blank",rel:"noopener noreferrer"},p=e("h3",{id:"总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#"),t(" 总结")],-1),u=e("p",null,"我这篇文章提出的分支管理策略是根据自己的实践经验总结的，能满足基本的要求。但这也只是个通用的模板，如何制定团队的 git 分支管理应该根据自己的具体情况而定，产品形态、团队人员配置都会影响到版本控制系统的使用。谢谢阅读，欢迎提出你的看法！",-1),m=e("h3",{id:"参考的文章",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#参考的文章","aria-hidden":"true"},"#"),t(" 参考的文章")],-1),g={href:"https://cloud.tencent.com/developer/article/1592957",target:"_blank",rel:"noopener noreferrer"},x={href:"https://www.jianshu.com/p/4d7512b78562",target:"_blank",rel:"noopener noreferrer"},v={href:"https://nvie.com/posts/a-successful-git-branching-model/",target:"_blank",rel:"noopener noreferrer"};function b(k,w){const r=d("ExternalLinkIcon");return n(),l("div",null,[h,e("p",null,[t("我为什么没有选用 dev 和 release 分离的方式呢？一方面我对以上两个优势没有强烈的需求，另外就是这样做需要频繁地合并代码，太麻烦了。结构复杂的产品和对测试工作投入较大的团队会因为优势1 而选择 dev / release 分离。如果想了解 dev / release 分离的方式具体是怎样工作的，可以参考这篇攻略："),e("a",f,[t("Git分支管理最佳实践"),o(r)]),t("，我就不在这里 copy 了。实际上这是一个老外提出的经典的版本控制系统工作模式，大而强，且麻烦... 原文在这里："),e("a",_,[t("A successful Git branching model"),o(r)]),t(" 。")]),p,u,m,e("ul",null,[e("li",null,[e("a",g,[t("Git 代码分支管理规范"),o(r)])]),e("li",null,[e("a",x,[t("Git分支管理最佳实践"),o(r)])]),e("li",null,[e("a",v,[t("A successful Git branching model"),o(r)])])])])}const V=i(c,[["render",b],["__file","2023-11-12-git-guide-team-strategy.html.vue"]]);export{V as default};
